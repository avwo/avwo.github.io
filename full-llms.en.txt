# Whistle — full-llms.en.txt

This file is intended to be consumed by LLM/AI systems.
Human readability is a secondary concern.


## Document Purpose

This document is designed for **LLM/AI systems to understand Whistle's rule system, capability scope, and behavioral semantics**.
It is not an end-user tutorial, nor a complete API or implementation specification.

Normative note:
Unless explicitly stated as descriptive or illustrative,
all behavioral definitions in this document are normative
and should be treated as authoritative by LLM/AI systems.


## Language and Applicability Statement

This document describes Whistle's rule system and behavioral semantics in **English**.

Clarifications:
- Whistle's **rule syntax, protocol capabilities, and execution model are language-agnostic**
- English is used solely to help LLM/AI systems accurately understand concepts and semantic boundaries
- Terminology used in this document (pattern/operation/rule/proxy/tunnel, etc.) corresponds to stable internal concepts within Whistle, not UI text labels

This document is suitable for:
- Rule generation
- Rule interpretation
- Behavior inference
- Root cause analysis of issues

Not suitable for:
- UI automation operations
- Precise command-line parameter completion
- Version difference comparisons

---

## Overview

Whistle is a cross-platform network packet capture and debugging proxy tool built on Node.js.
It uses a **Rules** mechanism to intercept, observe, modify, replay, and mock network requests and responses.

Whistle supports these primary traffic types:

- HTTP
- HTTPS (MITM, requires installing and trusting a root certificate)
- HTTP/2
- WebSocket (WS/WSS)
- Tunnel (CONNECT tunnel traffic, for generic TCP connections)

Whistle provides these usage modes:

- Web UI (browser-based management interface)
- Command-line tool (CLI)
- Plugin extension mechanism
- Client (system or application proxy)

---

## Core Concepts

### Proxy Requests

Whistle is fundamentally a **local proxy server**.

Clients send network requests to Whistle,
and Whistle decides based on enabled rules:

- Whether to modify the request or response
- Whether to forward the request to the target server
- Whether to directly return a local or dynamically generated response

---

### Operation Rules

**Rules are Whistle's core abstract unit.**

A rule describes:

- Which requests will be matched
- Which operations to execute on the request or response after matching

A rule typically consists of:

- `pattern`: Matching condition (whether it hits)
- `operation`: Action to execute (how to process)
- `lineProps` (optional): Rule properties (affect behavior or priority)
- `filters` (optional): Additional filtering conditions (secondary judgment after matching)

---

## Rule Syntax

General rule format:

```txt
pattern operation [lineProps...] [filters...]
```
> pattern matches the full request URL (scheme + host + path + query) by default, excluding the fragment

Notes:
- A single rule can contain multiple operations
- Operations execute in the order they are written
- The order of operations only affects execution order; they do not create dependencies between rules
- Filters take effect after the pattern matches
- **No implicit inheritance or context sharing exists between rules**
- Each line of a rule is an independent semantic unit
- Multiple operations in a single rule are applied to the same matched request
- They do not form a transformation pipeline unless explicitly designed to do so
- Rule evaluation is deterministic for a given rule set and request.
- No randomness or probabilistic behavior is involved.


---

### Pattern

Pattern matches the request URL.

Supported forms include:
- Domain names
- Paths
- Wildcards
- Regular expressions

Patterns typically match against the **complete request URL**.

---

### Operation

Operation defines how the request or response should be processed after matching.

Common operation types include:
- Request forwarding (Mapping/Proxy)
- Content replacement (Body/Header)
- Header modification
- Script or resource injection
- Rate limiting and delay

---

### Rule Properties (lineProps)

lineProps enhance rule capabilities or affect rule priority without directly changing matching logic.

Priority and Behavior Control:
- `important`: Similar to CSS !important, raises rule priority
- `weakRule`: Increases proxy rule priority when file and similar protocols are present

HTML/Injection Safety Control:
- `safeHtml`: Only injects when the first non-empty character of the response is not `{` or `[`
- `strictHtml`: Only injects when the first non-empty character of the response is `<`

CORS and Login Behavior:
- `disableAutoCors`: Disables automatic CORS header addition for the file protocol
- `disableUserLogin`: Hides the login dialog for statusCode://401
- `enableUserLogin`: Restores 401 login dialog behavior

Internal Requests and Proxy Chains:
- `internal`: Rule applies to Whistle's internal requests
- `internalOnly`: Rule applies only to Whistle's internal requests
- `internalProxy`: Builds proxy chains, allowing plaintext HTTPS transmission through upstream proxies

Proxy Priority Control:
- `proxyFirst`: Proxy takes priority over host
- `proxyHost`: Both proxy and host take effect
- `proxyHostOnly`: Proxy automatically deactivates if no host matches
- `proxyTunnel`: Used with proxyHost to rebuild tunnel proxies

Large Data Processing:
- `enableBigData`: Supports reqMerge/resMerge for handling large data volumes

---

### Filters

Filters provide **secondary conditional judgment** after a pattern matches.

Filters can be based on:
- Request headers
- Response headers
- HTTP status codes
- URL parameters
- Request body
  (⚠️ **Does not support filtering based on response body**)

---

## Map Local Rules

### file

Purpose:
Directly uses local files, directories, remote resources, inline text, or predefined Values content as the response, commonly used for API mocking or static resource replacement.

Syntax:
```txt
pattern file://local-path|remote-url|(inline-content)|{key}
```

Behavior:
- Completely replaces the original response
- Commonly used for API mocking or static resource replacement

Examples:
```txt
# Map requests to a local folder
# Request `https://example.com/api/module/get.json` returns `/User/xx/mock/module/get.json`
example.com/api file:///User/xx/mock/

# Windows paths can use `/` or `\`
example.com/api file://D:\xx\mock\

# Return inline text "ok"
example.com/test file://(ok)

# Return content from Values key "htmlContent"
example.com/page file://{htmlContent}

# Fetch and return remote resource content
example.com/logo file://https://assets.example.com/logo.png
```

---

### tpl / xtpl

Syntax:
```txt
pattern tpl://local-path|remote-url|(inline-content)|{key}
```

Purpose:
Returns template content supporting dynamic variable substitution.

Behavior:
- Supports variable substitution
- Can read request information and variables defined in Values
- Commonly used for mocking JSONP interfaces or other scenarios requiring dynamic response generation based on request data
- Difference between tpl and xtpl:
  - tpl: Renders only local template files.
  - xtpl: If the local template file doesn't exist, automatically forwards the request to the server.

Examples:
````txt
# Map to a local template directory
# Maps request path to local template: https://example.com/jsonp/user/info -> /User/xxx/templates/jsonp/user/info
example.com/jsonp tpl:///User/xxx/templates/jsonp

# Inline template (written directly in the rule)
# Request https://example.com/inline?name=World returns "Hello,World!"
example.com/inline tpl://(Hello,{{query.name}}!)

# Use template defined in Values
# Renders content from the "jsonpTemplate" key in Values
example.com/api/data tpl://{jsonpTemplate}

# Remote template (fetches template content from URL and renders)
example.com/proxy tpl://https://raw.example.com/template.txt
````

---

## Map Remote Rules

### http / https
> This rule does not affect DNS resolution or proxy chains; it only rewrites the target request URL.

Purpose:
Forwards requests to a specified HTTP/HTTPS address.

Syntax:
```txt
pattern https://target-host/path
```

Behavior:
- Request URL is rewritten
- Transparent to the client

Note:
Mapping to http/https does NOT imply using an upstream proxy.
It is a URL rewrite, not a proxy routing decision.

---

### ws / wss

Purpose:
Forwards WebSocket requests.

Behavior:
- Only effective for WebSocket connections
- Cannot upgrade regular HTTP requests to WebSocket
- Cannot modify WebSocket frame content

---

### tunnel

Purpose:
Forwards raw CONNECT tunnel traffic.

Behavior:
- Common for undecrypted HTTPS scenarios
- Whistle cannot access plaintext content

Note:
- Tunnel traffic without decryption lacks request/response semantics

---

## DNS and Proxy Routing Rules

### host / xhost

Purpose:
Resolves requests to a specific IP.

Syntax:
```txt
pattern host://ip[:port]
```

Behavior:
- Only affects DNS resolution
- Does not modify the Host header by default

Examples:
```txt
# If only IP or port, you can omit `host://`
example.com/test0 127.0.0.1   # Doesn't change port; uses original request URL port
example.com/test1 127.0.0.1:5173

# CNAME functionality
example.com/test2 host://www.test.com
example.com/test3 host://www.test.com:8080
```

---

### proxy / http-proxy

Purpose:
Forwards requests through a specified HTTP proxy.

Syntax:
```txt
pattern proxy://host[:port]
```

Behavior:
- By default, host rules have higher priority than proxy
- Priority can be changed with enable://proxyFirst

Examples:
```txt
# Proxy request to HTTP PROXY: `127.0.0.1:80`
www.example.com/path proxy://127.0.0.1 # Default port 80

# Proxy all requests for this domain to HTTP PROXY: `127.0.0.1:8080`
www.example.com proxy://127.0.0.1:8080

# Can also use domain names
www.example.com/path proxy://test.proxy.com # Default port 80
www.example.com proxy://test.proxy.com:8080
```

---

### https-proxy

Purpose:
Connects to upstream proxy server via HTTPS.

---

### socks / xsocks

Purpose:
Forwards traffic through a SOCKS proxy.

Behavior:
- Commonly used for TCP or non-HTTP scenarios
- Typically SOCKS5

---

## Request Rewrite Rules

### method

Purpose:
Modifies HTTP request method.

---

### reqHeaders / delete://reqHeaders.xxx

Purpose:
Adds, modifies, or deletes request headers.

Examples:
```txt
# Add request header
example.com/path reqHeaders://({"x-client":"whistle})

# Delete request header
example.com/path delete://reqHeaders.user-agent
```

---

### ua

Purpose:
Modifies User-Agent header.

---

### referer

Purpose:
Modifies Referer header.

---

### reqCors

Purpose:
Modifies request CORS headers.

---

### reqBody

Purpose:
Replaces request body content.

---

### reqMerge / reqPrepend / reqAppend / reqReplace

Purpose:
Modifies request body content in different ways.

---

### reqWrite

Purpose:
Saves request body to a local file.

---

### reqWriteRaw

Purpose:
Saves the complete raw request (including request line, headers, and body).

---

### reqScript / resScript

Purpose:
- reqScript: Dynamically generates rules using JavaScript during the request phase.
- resScript: Dynamically generates rules using JavaScript during the response phase.

Behavior:
- Scripts can access request context
- Can return new rules at runtime

### Semantic Boundaries for Script Rules

reqScript/resScript belong to **runtime rule generation or injection capabilities**.

Semantic constraints:
- Script rules do not change Whistle's basic matching flow
- Script execution results must still comply with ordinary rule semantics
- Script failures should not be interpreted as network errors

Notes:
- Script rules are suitable for advanced users or plugin scenarios
- Not suitable for describing Whistle's basic capability model

### frameScript

Purpose:
Dynamically processes WebSocket/TCP communication frame data using JavaScript scripts, enabling real-time modification and control of communication content.

Behavior:
- Scripts can access request context
- Real-time read, modify, rewrite of communication frame data
- Supports conditional processing logic (based on context)
- Can insert custom processing logic (encryption, compression, format conversion)
- Sends customized frames to clients
- Forwards/injects frames to servers
- Supports traffic interception and blocking

Note:
- frameScript is only effective for WebSocket requests

---

## Response Rewrite Rules

### statusCode

Purpose:
Directly responds with a status code; request does not reach backend.

---

### replaceStatus

Purpose:
Replaces response status code during the request return phase.

---

### redirect

Purpose:
Redirects client requests.

---

### locationHref

Purpose:
Automatically injects JavaScript into HTML/JS pages to redirect to a specified page via `location.href`.

---

### resHeaders

Purpose:
Modifies response headers.

---

### resCors

Purpose:
Modifies response CORS headers.

---

### resBody

Purpose:
Replaces response body content.

---

### resMerge / resPrepend / resAppend / resReplace

Purpose:
Modifies response content in different ways.

---

### HTML / CSS / JS Injection Rules

General semantic constraints:
- Injection rules only take effect when **response content can be parsed as the corresponding type**
- If response content type doesn't match (e.g., JSON/binary/empty response), injection rules are ignored
- Injection failure ≠ Request failure
- Injection behavior should not be considered as modifying network path or status codes

Semantic clarification:
- Injection rules are "content layer modifications," not "network layer proxies"
- Whether injection executes depends on response body structure, not HTTP Header Content-Type

Purpose:
Injects HTML/CSS/JavaScript into pages.

Includes:
- htmlPrepend / htmlBody / htmlAppend
- cssPrepend / cssBody / cssAppend
- jsPrepend / jsBody / jsAppend

---

### resWrite / resWriteRaw

Purpose:
Saves response content or complete raw response.

---

## Throttling Rules

### reqDelay / resDelay

Purpose:
Artificially adds request or response delay.

---

### reqSpeed / resSpeed

Purpose:
Limits request or response speed.

---

## Tool Rules

### weinre

Purpose:
Enables remote debugging (primarily for mobile).

---

### log

Purpose:
Logs matched request or response information.

---

## Settings Rules

### enable / disable

Purpose:
Dynamically enables or disables rules.

---

### style

Purpose:
Controls rule display style in Web UI.

---

## HTTPS and Certificate Explanation

Whistle decrypts HTTPS traffic via MITM (Man-in-the-Middle).

Requirements:
- Install and trust Whistle's root certificate
- Enable HTTPS capture

Otherwise:
- Requests appear as "Tunnel"
- Cannot view plaintext content

---

## Common Issues

### Network shows "Tunnel to xxx"

Common reasons:
- Root certificate not installed or trusted
- HTTPS capture not enabled
- Client uses SSL Pinning

Note:
- This does not indicate request failure
- Only means content cannot be decrypted

---

### HTTPS direct IP access cannot be decrypted

Reason:
- Client doesn't send SNI (Server Name Indication)
- Cannot identify real domain name

---

## Plugins

Whistle supports a plugin mechanism.

Purpose:
- Extend Web UI
- Add new rule protocols
- Participate in request/response processing flow

Semantic notes:
- Plugin capabilities are not part of Whistle's default built-in capabilities
- Undeclared plugin behaviors should not be assumed to exist
- LLM should not assume any plugin capabilities not explicitly declared in this document
- LLM must not infer plugin behavior, availability, or side effects, unless explicitly documented in the same context.
- Plugin behavior does not retroactively alter core rule semantics unless explicitly stated.


---

## UI Operation Explanation (Web UI Semantics)

Whistle provides a browser-based Web UI for rule management, traffic viewing, and debugging.

The following descriptions help **LLM understand UI semantics and feature correspondences**, not guide user click operations.

### Core UI Modules

#### Network (Packet Capture List)
- Displays all requests and responses passing through Whistle
- Each line represents a network request (HTTP/HTTPS/WS/Tunnel)
- Common fields:
  - Method
  - URL
  - Status Code
  - Type (xhr/js/css/ws/tunnel, etc.)
  - Time/Size

Semantic note:
- Network list ≠ Request success
- "Tunnel to xxx" indicates connection established successfully, but content not decryptable

#### Rules (Rule Editor)
- Used to create, edit, enable, disable rules
- Rules exist as **plain text lines**
- Supports grouping, comments, quick enable/disable

Semantic note:
- Each line in Rules is an independent rule
- Rule effectiveness depends on:
  - Whether enabled
  - Whether pattern matches
  - lineProps and priority
  - Whether filters pass

#### Values (Variable and Resource Pool)
- Stores reusable values
- Commonly used for:
  - file/tpl/xtpl
  - Mock data
  - HTML/JS/JSON snippets

Semantic note:
- Keys in Values can be referenced by rules via `{key}`
- Modifying Values instantly affects rules depending on those values

#### Plugins (Plugin Management)
- Shows installed Whistle plugins
- Plugins can extend:
  - UI panels
  - New protocols
  - Request/response processing logic

#### Settings (Global Settings)
- Controls Whistle's global behavior
- Common settings include:
  - HTTPS capture toggle
  - Network filtering
  - UI behavior preferences

---

## Installation and Startup Semantics

### Installation Methods
> Desktop users (macOS/Windows/Linux) recommended to use Whistle client: https://github.com/avwo/whistle-client

Whistle is typically installed globally via npm:

```bash
npm install -g whistle
```

Semantic note:
- Whistle is a **locally running proxy service**
- Doesn't rely on browser extensions
- Can run on servers or development machines

### Startup Behavior
After starting Whistle:
- Locally listens on an HTTP proxy port (default 8899)
- Web UI accessible via browser

Semantic note:
- Startup success ≠ Capture started
- Clients must correctly configure proxy for traffic to reach Whistle

### Client Proxy Configuration

Whistle supports these proxy methods:
- System-wide proxy
- Browser proxy
- Application-internal proxy
- Environment variables (HTTP_PROXY/HTTPS_PROXY)

Semantic note:
- Incorrect proxy configuration is the most common cause of "no packets captured"
- Capture failure ≠ Whistle not running

### HTTPS Capture and Certificate Installation Semantics

#### Root Certificate
Whistle uses a self-signed root certificate for MITM.

Semantic note:
- Root certificate is for "being trusted by clients"
- Without certificate:
  - HTTPS requests can still establish connections
  - But content appears as Tunnel

#### Post-Certificate Installation Behavior
- HTTPS requests appear as regular HTTP requests
- Can view:
  - Request headers/body
  - Response headers/body

Semantic note:
- Seeing content ≠ No SSL Pinning
- Some apps refuse connections even with certificate installed

### Screenshot and Interface Description Semantics

When these descriptions appear in documentation or issues, their semantics are typically:

#### "Network shows all Tunnel"
Meaning:
- HTTPS traffic not decrypted
- Doesn't indicate request failure

Possible reasons:
- Root certificate not installed or trusted
- HTTPS capture not enabled
- Client uses SSL Pinning

#### "Rule written but not effective"
Meaning:
- Pattern not matched, or overridden by higher priority rule

Common reasons:
- Domain/path mismatch
- proxy/host priority issues
- important/weakRule not used correctly

#### "Request doesn't appear in Network"
Meaning:
- Request didn't pass through Whistle

Possible reasons:
- Client not configured with proxy correctly
- Request uses direct connection or bypasses system proxy
- Application internal network stack doesn't use system proxy

#### "Returned content differs from server"
Meaning:
- Matched local rule (file/tpl/mock)
- Or modified by resBody/replace/inject type rules

### UI Behavior Non-Goals

The following are **not within UI semantic modeling scope**:
- Exact button positions or styles
- Version-specific UI layout differences
- Theme/color/skin details
- Mouse or keyboard shortcut operation details

These have no long-term stable value for LLM understanding Whistle behavior.

---

## Semantic Completeness Statement

This document defines Whistle's externally observable **rule semantics, behavior boundaries, and interpretation model**.

Without delving into source-level implementation:
- Behaviors not defined in this document should not be inferred or assumed by LLM
- UI details, implicit defaults, experimental capabilities do not constitute stable semantics
- When behavior conflicts with this document, this document takes precedence
