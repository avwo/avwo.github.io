import{_ as a,c as s,o as n,ae as l}from"./chunks/framework.Dgg8-8ov.js";const x=JSON.parse('{"title":"enable","description":"","frontmatter":{},"headers":[],"relativePath":"docs/rules/enable.md","filePath":"docs/rules/enable.md"}'),p={name:"docs/rules/enable.md"};function t(c,e,o,i,d,r){return n(),s("div",null,e[0]||(e[0]=[l(`<h1 id="enable" tabindex="-1">enable <a class="header-anchor" href="#enable" aria-label="Permalink to &quot;enable&quot;">​</a></h1><p>通过规则启用 HTTPS、隐藏请求、终止请求等功能。</p><h2 id="规则语法" tabindex="-1">规则语法 <a class="header-anchor" href="#规则语法" aria-label="Permalink to &quot;规则语法&quot;">​</a></h2><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pattern enable://action1|action2|... [filters...]</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 等效于：</span></span>
<span class="line"><span>pattern enable://action1 enable://action2 ... [filters...]</span></span></code></pre></div><table tabindex="0"><thead><tr><th>参数</th><th>描述</th><th>详细文档</th></tr></thead><tbody><tr><td>pattern</td><td>匹配请求 URL 的表达式</td><td><a href="./pattern.html">匹配模式文档</a></td></tr><tr><td>action</td><td>具体动作，详见下面的说明</td><td></td></tr><tr><td>filters</td><td>可选过滤器，支持匹配：<br>• 请求URL/方法/头部/内容<br>• 响应状态码/头部</td><td><a href="./filters.html">过滤器文档</a></td></tr></tbody></table><ul><li><code>capture</code> 或 <code>https</code>：Enable HTTPS（同 <a href="./../gui/https.html">HTTPS菜单功能</a>）</li><li><code>authCapture</code>：强制在转成 HTTPS 之前执行 <a href="./../extensions/dev.html#auth">auth hook</a>（默认是转成 HTTPS 请求后再执行插件的 auth hook）</li><li><code>abort</code>：请求或响应阶段中断请求（根据匹配阶段）</li><li><code>abortReq</code>：请求阶段中断请求</li><li><code>abortRes</code>：响应阶段中断请求</li><li><code>br</code>：启用 BR 压缩响应内容</li><li><code>gzip</code>：启用 GZIP 压缩响应内容</li><li><code>deflate</code>：启用 Deflate 压缩响应内容&lt;</li><li><code>proxyHost</code>：<a href="./proxy.html">proxy</a> 和 <a href="./host.html">host</a> 同时生效</li><li><code>proxyTunnel</code>：跟 <code>proxyHost</code> 一同使用，让上游代理再次通过隧道代理到上上游的 HTTP 代理，详见下面的示例</li><li><code>proxyFirst</code>：优先使用 <a href="./proxy.html">proxy</a> 规则</li><li><code>http2</code>：浏览器 -&gt; Whistle 代理 -&gt; 服务器全部启用 HTTP2</li><li><code>h2</code>：Whistle 代理 -&gt; 服务器启用 HTTP2</li><li><code>httpH2</code>：Whistle 代理 -&gt; 服务器的 HTTP 请求启用 HTTP2</li><li><code>safeHtml</code>：是一种安全防护机制，当使用 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code> 向 HTML 页面注入内容时，会先检查响应内容的第一个非空白字符是否为 <code>{</code> 和 <code>[</code>（JSON 对象开头字符），如果不是才会执行注入操作。这可以有效防止对非标准 HTML 响应（如 JSON 接口）的误注入</li><li><code>strictHtml</code>：是一种安全防护机制，当使用 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code> 向 HTML 页面注入内容时，会先检查响应内容的第一个非空白字符是否为 <code>&lt;</code>，如果不是才会执行注入操作。这可以有效防止对非标准 HTML 响应（如 JSON 接口）的误注入</li><li><code>clientIp</code>：为匹配的非本地请求设置 x-forwarded-for 请求头，将客户端的真实IP地址透传给上游服务</li><li><code>bigData</code>：扩大抓包数据显示限制(2M→16M)</li><li><code>forceReqWrite</code>：使用 <a href="./reqWrite.html">reqWrite</a>、<a href="./reqWriteRaw.html">reqWriteRaw</a> 将请求数据写入本地文件时，如果对应的文件已存在，默认跳过写入操作以保护现有文件，可以通过 <code>enable://forceReqWrite</code> 强制覆盖</li><li><code>forceResWrite</code>： 使用 <a href="./resWrite.html">resWrite</a>、<a href="./reqWriteRaw.html">reqWriteRaw</a> 将响应数据写入本地文件时，如果对应的文件已存在，默认跳过写入操作以保护现有文件，可以通过 <code>enable://forceResWrite</code> 强制覆盖</li><li><code>auto2http</code>：开启 HTTPS 请求报 TLS 错误自动转成 HTTP 请求，默认情况下如果 serverIP 是本地 IP 会自动启用</li><li><code>customParser</code>：自定义抓包界面显示内容，用法参考插件：<a href="https://github.com/whistle-plugins/whistle.custom-parser" target="_blank" rel="noreferrer">https://github.com/whistle-plugins/whistle.custom-parser</a></li><li><code>hide</code>：在界面上隐藏抓包数据</li><li><code>inspect</code>：使的在 Inspectors / Frames 看到 TUNNEL 请求的内容</li><li><code>keepCSP</code>：通过 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code> 注入内容时会自动删除响应头大 <code>csp</code> 字段，如果想保留这些字段可以用 <code>enable://keepCSP</code></li><li><code>keepAllCSP</code>：通过 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code>/<code>weinre</code>/<code>log</code> 注入内容时会自动删除响应头的 <code>csp</code> 字段，如果想保留这些字段可以用 <code>enable://keepCSP</code></li><li><code>keepCache</code>：通过 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code>/<code>weinre</code>/<code>log</code> 注入内容时会自动删除响应头的缓存字段，如果想保留自定义的缓存头可以用 <code>enable://keepCache</code></li><li><code>useLocalHost</code>：修改 <code>log</code> 和 <code>weinre</code> 请求 <code>URL</code> 的域名，使用内置域名</li><li><code>useSafePort</code>：修改 <code>log</code> 和 <code>weinre</code> 请求 <code>URL</code> 的端口，使用内置端口</li><li><code>userLogin</code>：设置 <a href="./statusCode.html">statusCode://401</a> 是否显示登录框（默认显示）</li></ul><h2 id="配置示例" tabindex="-1">配置示例 <a class="header-anchor" href="#配置示例" aria-label="Permalink to &quot;配置示例&quot;">​</a></h2><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># Enable HTTPS</span></span>
<span class="line"><span>www.example.com enale://https</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 延迟 3000毫秒终止请求</span></span>
<span class="line"><span>www.example.com/path reqDelay://3000 enable://abortReq</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 延迟 5000毫米终止响应</span></span>
<span class="line"><span>www.example.com/path resDelay://5000 enable://abortRes</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 本地替换的内容开启 GZIP</span></span>
<span class="line"><span>www.example.com/path file:///User/xxx/test enable://gzip</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 给上游代理设置 hosts (10.10.10.20:8888)</span></span>
<span class="line"><span>www.example.com/path proxy://10.1.1.1:8080 10.10.10.20:8888 enable://proxyHost</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 通过上游 HTTP 代理 (10.1.1.1:8080) 将请求通过隧道代理到指定的 HTTP 代理(10.10.10.20:8080)</span></span>
<span class="line"><span>www.example.com proxy://10.1.1.1:8080 10.10.10.20:8080 enable://proxyHost|proxyTunnel</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 启用浏览器 -&gt; Whistle 代理 -&gt; 服务器整个链路的 HTTP2 功能</span></span>
<span class="line"><span>www.example.com enable://http2</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 启用 Whistle 代理 -&gt; 服务器的 HTTP2 功能</span></span>
<span class="line"><span>www.example.com enable://h2</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 强制 Whistle 代理 -&gt; 服务器的 HTTP 请求使用 HTTP2 传输</span></span>
<span class="line"><span>www.example.com enable://httpH2</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 安全注入模式：当使用 htmlXxx/jsXxx/cssXxx 注入指令时，检测响应首字符不是 \`{\` 才注入</span></span>
<span class="line"><span>www.example.com/path enable://safeHtml</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 严格HTML注入模式：当使用 htmlXxx/jsXxx/cssXxx 注入指令时，检测响应首字符不是 \`&lt;\` 才注入</span></span>
<span class="line"><span>www.example.com/path enable://strictHtml</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 自动添加 x-forwarded-for 请求头传递客户端真实 IP</span></span>
<span class="line"><span>www.example.com enable://clientIp</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 扩大抓包数据显示限制(2M→16M)</span></span>
<span class="line"><span>www.example.com/path enable://bigData</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 修改 log/weinre 请求 \`URL\` 的域名或端口</span></span>
<span class="line"><span>www.example.com/path enable://useLocalHost|useSafePort</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 强制 reqWrite/reqWriteRaw/resWrite/resWriteRaw 覆盖已有的文件</span></span>
<span class="line"><span>www.example.com/path enable://forceReqWrite|forceResWrite</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 强制 HTTPS 请求被解析前也走 \`auth hook\`（默认是转成 HTTPS 请求后再执行插件的 auth hook）</span></span>
<span class="line"><span>www.example.com enable://authCapture</span></span></code></pre></div><p>关联操作：<a href="./disable.html">disable</a></p>`,9)]))}const m=a(p,[["render",t]]);export{x as __pageData,m as default};
