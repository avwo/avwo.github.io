import{_ as o,c as t,o as a,ag as c}from"./chunks/framework.Bw-5EFTY.js";const u=JSON.parse('{"title":"pattern","description":"","frontmatter":{},"headers":[],"relativePath":"docs/rules/pattern.md","filePath":"docs/rules/pattern.md"}'),d={name:"docs/rules/pattern.md"};function l(i,e,s,p,r,n){return a(),t("div",null,e[0]||(e[0]=[c(`<h1 id="pattern" tabindex="-1">pattern <a class="header-anchor" href="#pattern" aria-label="Permalink to &quot;pattern&quot;">​</a></h1><p>匹配请求 URL 的表达式，支持域名、路径、通配符、正则等匹配方式</p><h2 id="请求-url" tabindex="-1">请求 URL <a class="header-anchor" href="#请求-url" aria-label="Permalink to &quot;请求 URL&quot;">​</a></h2><p>请求 URL 有三种类型：</p><ol><li><strong>隧道代理：</strong> <code>tunnel://domain:port</code><blockquote><p>示例：<code>tunnel://www.test.com:443</code></p></blockquote></li><li><strong>WebSocket：</strong> <code>ws[s]://domain[:port]/[path/to[?query]]</code><blockquote><p>示例：<code>wss://www.test.com/path?a=1&amp;b=2</code></p></blockquote></li><li><strong>普通 HTTP/HTTPS：</strong> <code>http[s]://domain[:port]/[path/to[?query]]</code><blockquote><p>示例：<code>https://www.test.com/path?a=1&amp;b=2</code></p></blockquote></li></ol><h2 id="域名匹配" tabindex="-1">域名匹配 <a class="header-anchor" href="#域名匹配" aria-label="Permalink to &quot;域名匹配&quot;">​</a></h2><ol><li>正常域名： <ul><li><code>www.example.com</code>、</li><li><code>1.2.3.4</code></li><li><code>//www.example.com</code>、</li><li><code>//1.2.3.4</code><blockquote><p>IP 也可作为域名</p></blockquote></li></ul></li><li>带端口域名： <ul><li><code>www.example.com:8080</code>、</li><li><code>//www.example.com:8080</code>、</li></ul></li><li>带协议域名： <ul><li><code>tunnel://www.example.com[:port]</code></li><li><code>ws[s]://www.example.com[:port]</code></li><li><code>http[s]://www.example.com[:port]</code></li></ul></li></ol><h2 id="路径匹配" tabindex="-1">路径匹配 <a class="header-anchor" href="#路径匹配" aria-label="Permalink to &quot;路径匹配&quot;">​</a></h2><ol><li>无协议路径： <ul><li><code>www.example.com[:port]/[path/to[?query]]</code></li><li><code>//www.example.com[:port]/[path/to[?query]]</code></li></ul></li><li>带协议路径： <ul><li><code>ws[s]://www.example.com[:port]/[path/to[?query]]</code></li><li><code>http[s]://www.example.com[:port]/[path/to[?query]]</code><blockquote><p>TUNNEL 请求没有路径</p></blockquote></li></ul></li></ol><h2 id="通配符匹配" tabindex="-1">通配符匹配 <a class="header-anchor" href="#通配符匹配" aria-label="Permalink to &quot;通配符匹配&quot;">​</a></h2><h3 id="域名通配符规则" tabindex="-1">域名通配符规则 <a class="header-anchor" href="#域名通配符规则" aria-label="Permalink to &quot;域名通配符规则&quot;">​</a></h3><ol><li><strong>基础通配符</strong>：<code>*.example.com[:port][/path][?query]</code><blockquote><p><code>*</code> 匹配任意非分隔符字符（正则：<code>/[^./?]*/</code>）</p><p>示例：<code>api.example.com</code>、<code>shop.example.com:8080</code></p></blockquote></li><li><strong>多级通配符</strong>：<code>**.example.com[:port][/path][?query]</code><blockquote><p><code>**</code> 匹配任意多级子域（正则：<code>/[^/?]*/</code>）</p><p>示例：<code>a.b.example.com</code>、<code>x.y.z.example.com/path</code></p></blockquote></li><li><strong>混合通配符</strong>：<code>test.abc**.com[:port][/path][?query]</code><blockquote><p><code>**</code> 固定前缀 + 多级通配（正则：<code>/[^/?]*/</code>）</p><p>示例：<code>test.abc123.com</code>、<code>test.abc123.x.com</code>、<code>test.abc.a.b.com</code></p></blockquote></li><li><strong>协议通配符</strong>：<code>http*://test.abc**.com[:port][/path][?query]</code><blockquote><p>协议中的 <code>*</code> 匹配任意字母或冒号（正则：<code>/[a-z:]*/</code>）</p><p>示例：<code>https://...</code>、<code>http://...</code></p></blockquote></li><li><strong>特殊规则</strong>：<code>***.example.com[:port][/path][?query]</code><blockquote><p>相当于同时匹配：根域名（example.com）+ 多级子域（**.example.com）</p><p>示例：example.com、a.example.com、a.b.example.com/path?q=1</p></blockquote></li></ol><p>除上述特殊规则（<code>***.</code>）外，协议或域名部分出现3个及以上连续的星号（如或 <code>***</code>、<code>****</code>）时，其功能等同于2个星号（<code>**</code>）</p><h3 id="路径通配符" tabindex="-1">路径通配符 <a class="header-anchor" href="#路径通配符" aria-label="Permalink to &quot;路径通配符&quot;">​</a></h3><p>由于 <code>*</code> 是合法的 URL 路径字符，当需要将其作为通配符使用时，在表达式前面加 <code>^</code> 显式声明：</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>^[[schema:]//]domain[:port]/pa**th?qu*ery</span></span></code></pre></div><blockquote><p>示例：<code>^http*://**.example.com/data/*/result?q=*23</code></p></blockquote><p>协议和域名的通配符功能同上面的域名通配符规则，纯路径及请求参数的通配符规则如下：</p><h5 id="路径部分的通配符" tabindex="-1">路径部分的通配符 <a class="header-anchor" href="#路径部分的通配符" aria-label="Permalink to &quot;路径部分的通配符&quot;">​</a></h5><table tabindex="0"><thead><tr><th>通配符</th><th>正则等价</th><th>匹配范围</th><th>示例匹配</th></tr></thead><tbody><tr><td><code>*</code></td><td><code>/[^?/]*/</code></td><td>单级路径（不含 <code>/</code> 和 <code>?</code>）</td><td><code>^.../*/*.js</code> -&gt; <code>.../a/b.js</code></td></tr><tr><td><code>**</code></td><td><code>/[^?]*/</code></td><td>多级路径（不含 <code>?</code>）</td><td><code>^.../**file</code> -&gt; <code>.../a/b/c/test-file</code></td></tr><tr><td><code>***</code></td><td><code>/.*/</code></td><td>任意字符（含 <code>/</code> 和 <code>?</code>）</td><td><code>^.../data/***file</code> -&gt; <code>.../a/b/c?test=file</code></td></tr></tbody></table><h5 id="请求参数部分的通配符" tabindex="-1">请求参数部分的通配符 <a class="header-anchor" href="#请求参数部分的通配符" aria-label="Permalink to &quot;请求参数部分的通配符&quot;">​</a></h5><table tabindex="0"><thead><tr><th>通配符</th><th>正则等价</th><th>匹配范围</th><th>示例匹配</th></tr></thead><tbody><tr><td><code>*</code></td><td><code>/[^&amp;]*/</code></td><td>单参数值（不含 <code>&amp;</code>）</td><td><code>^...?q=*123</code> -&gt; <code>...?q=abc123</code></td></tr><tr><td><code>**</code></td><td><code>/.*/</code></td><td>任意字符（含 <code>&amp;</code>）</td><td><code>^...?q=**123</code> -&gt; <code>...?q=abc&amp;test=123</code></td></tr></tbody></table><h2 id="正则匹配" tabindex="-1">正则匹配 <a class="header-anchor" href="#正则匹配" aria-label="Permalink to &quot;正则匹配&quot;">​</a></h2><p>除简单匹配规则外，Whistle 提供完整的正则表达式支持，语法与 JavaScript 正则完全兼容：</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/pattern/[flags]</span></span></code></pre></div><ul><li>pattern：正则表达式主体</li><li>flags：匹配模式修饰符（可选）支持： <ul><li><code>i</code> 忽略大小写 <code>/abc/i</code> 匹配 &quot;AbC&quot;</li><li><code>u</code> 启用 Unicode 支持 <code>/\\p{Emoji}/u</code> 匹配 &quot;😀&quot;</li></ul></li></ul><p>示例：</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/\\.test\\./          # 匹配 &quot;.test.&quot;</span></span>
<span class="line"><span>/key=value/i        # 忽略大小写匹配 &quot;key=value&quot;</span></span>
<span class="line"><span>/\\/statics\\//ui     # Unicode 模式匹配 &quot;/statics/&quot;</span></span></code></pre></div><h2 id="子匹配传值" tabindex="-1">子匹配传值 <a class="header-anchor" href="#子匹配传值" aria-label="Permalink to &quot;子匹配传值&quot;">​</a></h2><p>在 Whistle 的规则配置中，可以通过 $0、$1 至 $9 引用通配符或正则表达式匹配的子匹配内容，并将其传递到操作值中：</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pattern protocol://$0_$1_$2_..._$1</span></span></code></pre></div><ul><li><strong>$0</strong>：完整匹配结果</li><li><strong>$1 - $9</strong>：对应捕获组的内容</li></ul><h4 id="通配符匹配传值" tabindex="-1">通配符匹配传值 <a class="header-anchor" href="#通配符匹配传值" aria-label="Permalink to &quot;通配符匹配传值&quot;">​</a></h4><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>^http://*.example.com/v0/users/** file:///User/xxx/$1/$2</span></span></code></pre></div><ul><li><strong>匹配</strong>：<code>http://www.example.com/v2/users/alice/test.html?q=1</code></li><li><strong>传值</strong>： <ul><li><code>$1</code> = <code>www</code></li><li><code>$2</code> = <code>users/alice</code></li></ul></li><li>结果：替换本地文件 <code>/User/xxx/www/alice/test.html</code> 的内容</li></ul><h4 id="正则匹配传值" tabindex="-1">正则匹配传值 <a class="header-anchor" href="#正则匹配传值" aria-label="Permalink to &quot;正则匹配传值&quot;">​</a></h4><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/regexp\\/(user|admin)\\/(\\d+)/ reqHeaders://X-Type=$1&amp;X-ID=$2</span></span></code></pre></div><ul><li><strong>匹配</strong>：<code>.../regexp/admin/123</code></li><li><strong>传值</strong>： <ul><li><code>$1</code> = <code>admin</code></li><li><code>$2</code> = <code>123</code></li></ul></li><li><strong>结果</strong>：添加请求头 <code>X-Type: admin</code> 和 <code>X-ID: 123</code></li></ul>`,38)]))}const m=o(d,[["render",l]]);export{u as __pageData,m as default};
