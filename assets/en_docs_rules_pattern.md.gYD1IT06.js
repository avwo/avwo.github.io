import{_ as a,c as t,o,ae as c}from"./chunks/framework.Dgg8-8ov.js";const u=JSON.parse('{"title":"pattern","description":"","frontmatter":{},"headers":[],"relativePath":"en/docs/rules/pattern.md","filePath":"en/docs/rules/pattern.md"}'),l={name:"en/docs/rules/pattern.md"};function d(s,e,i,r,n,p){return o(),t("div",null,e[0]||(e[0]=[c(`<h1 id="pattern" tabindex="-1">pattern <a class="header-anchor" href="#pattern" aria-label="Permalink to &quot;pattern&quot;">‚Äã</a></h1><p>An expression that matches the request URL. Supports domain name, path, wildcard, and regular expression matching.</p><h2 id="request-url" tabindex="-1">Request URL <a class="header-anchor" href="#request-url" aria-label="Permalink to &quot;Request URL&quot;">‚Äã</a></h2><p>There are three types of request URLs:</p><ol><li><strong>Tunnel proxy:</strong> <code>tunnel://domain:port</code><blockquote><p>Example: <code>tunnel://www.test.com:443</code></p></blockquote></li><li><strong>WebSocket:</strong> <code>ws[s]://domain[:port]/[path/to[?query]]</code><blockquote><p>Example: <code>wss://www.test.com/path?a=1&amp;b=2</code></p></blockquote></li><li><strong>Normal HTTP/HTTPS:</strong> <code>http[s]://domain[:port]/[path/to[?query]]</code><blockquote><p>Example: <code>https://www.test.com/path?a=1&amp;b=2</code></p></blockquote></li></ol><h2 id="domain-name-matching" tabindex="-1">Domain name matching <a class="header-anchor" href="#domain-name-matching" aria-label="Permalink to &quot;Domain name matching&quot;">‚Äã</a></h2><ol><li>Normal domain name: <ul><li><code>www.example.com</code>,</li><li><code>1.2.3.4</code></li><li><code>//www.example.com</code>,</li><li><code>//1.2.3.4</code></li></ul><blockquote><p>IP addresses can also be used as domain names</p></blockquote></li><li>Domain names with ports: <ul><li><code>www.example.com:8080</code></li><li><code>//www.example.com:8080</code></li></ul></li><li>Domain names with protocols: <ul><li><code>tunnel://www.example.com[:port]</code></li><li><code>ws[s]://www.example.com[:port]</code></li><li><code>http[s]://www.example.com[:port]</code></li></ul></li></ol><h2 id="path-matching" tabindex="-1">Path Matching <a class="header-anchor" href="#path-matching" aria-label="Permalink to &quot;Path Matching&quot;">‚Äã</a></h2><ol><li>Path without a protocol: <ul><li><code>www.example.com[:port]/[path/to[?query]]</code></li><li><code>//www.example.com[:port]/[path/to[?query]]</code></li></ul></li><li>Path with a protocol: <ul><li><code>ws[s]://www.example.com[:port]/[path/to[?query]]</code></li><li><code>http[s]://www.example.com[:port]/[path/to[?query]]</code></li></ul><blockquote><p>TUNNEL request without a path</p></blockquote></li></ol><h2 id="wildcard-matching" tabindex="-1">Wildcard Matching <a class="header-anchor" href="#wildcard-matching" aria-label="Permalink to &quot;Wildcard Matching&quot;">‚Äã</a></h2><h3 id="domain-wildcard-rules" tabindex="-1">Domain Wildcard Rules <a class="header-anchor" href="#domain-wildcard-rules" aria-label="Permalink to &quot;Domain Wildcard Rules&quot;">‚Äã</a></h3><ol><li><strong>Basic Wildcard</strong>: <code>*.example.com[:port][/path][?query]</code><blockquote><p><code>*</code> matches any non-delimiter character (regular pattern: <code>/[^./?]*/</code>)</p><p>Examples: <code>api.example.com</code>, <code>shop.example.com:8080</code></p></blockquote></li><li><strong>Multi-Level Wildcard</strong>: <code>**.example.com[:port][/path][?query]</code><blockquote><p><code>**</code> matches any multi-level subdomain (regular pattern: <code>/[^/?]*/</code>)</p><p>Examples: <code>a.b.example.com</code>, <code>x.y.z.example.com/path</code></p></blockquote></li><li><strong>Mixed wildcards</strong>: <code>test.abc**.com[:port][/path][?query]</code><blockquote><p><code>**</code> fixed prefix + multi-level wildcard (regular pattern: <code>/[^/?]*/</code>)</p><p>Examples: <code>test.abc123.com</code>, <code>test.abc123.x.com</code>, <code>test.abc.a.b.com</code></p></blockquote></li><li><strong>Protocol wildcard</strong>: <code>http*://test.abc**.com[:port][/path][?query]</code><blockquote><p><code>*</code> in the protocol matches any letter or colon (regular pattern: /[a-z:]*/)</p><p>Examples: <code>https://...</code>, <code>http://...</code></p></blockquote></li><li><strong>Special rule</strong>: <code>***.example.com[:port][/path][?query]</code><blockquote><p>This is equivalent to matching: the root domain (example.com) + multiple subdomains (**.example.com)</p><p>Examples: example.com, a.example.com, a.b.example.com/path?q=1</p></blockquote></li></ol><p>Except for the special rules above (<code>***.</code>), three or more consecutive asterisks (e.g., <code>***</code>„ÄÅ<code>****</code>) in the protocol or domain name are equivalent to two asterisks (<code>**</code>).</p><h3 id="path-wildcards" tabindex="-1">Path Wildcards <a class="header-anchor" href="#path-wildcards" aria-label="Permalink to &quot;Path Wildcards&quot;">‚Äã</a></h3><p>Since * is a valid URL path character, when using it as a wildcard, explicitly declare it by preceding the expression with ^ :</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>^[[schema:]//]domain[:port]/pa**th?qu*ery</span></span></code></pre></div><blockquote><p>Example: ^http*üòï/**.example.com/data/*/result?q=*23</p></blockquote><p>Wildcards for protocols and domain names function the same as for domain name wildcards above. Wildcards for pure paths and request parameters are as follows:</p><h5 id="path-wildcards-1" tabindex="-1">Path Wildcards <a class="header-anchor" href="#path-wildcards-1" aria-label="Permalink to &quot;Path Wildcards&quot;">‚Äã</a></h5><table tabindex="0"><thead><tr><th>Wildcards</th><th>Regular Expression Equivalence</th><th>Match Range</th><th>Example Match</th></tr></thead><tbody><tr><td><code>*</code></td><td><code>/[^?/]*/</code></td><td>Single-level path (excluding <code>/</code> and <code>?</code>)</td><td><code>^.../*/*.js</code> -&gt; <code>.../a/b.js</code></td></tr><tr><td><code>**</code></td><td><code>/[^?]*/</code></td><td>Multi-level path (excluding <code>?</code>)</td><td><code>^.../**file</code> -&gt; <code>.../a/b/c/test-file</code></td></tr><tr><td><code>***</code></td><td><code>/.*/</code></td><td>Any character (including <code>/</code> and <code>?</code>)</td><td><code>^.../data/***file</code> -&gt; <code>.../a/b/c?test=file</code></td></tr></tbody></table><h5 id="wildcards-in-request-parameters" tabindex="-1">Wildcards in Request Parameters <a class="header-anchor" href="#wildcards-in-request-parameters" aria-label="Permalink to &quot;Wildcards in Request Parameters&quot;">‚Äã</a></h5><table tabindex="0"><thead><tr><th>Wildcards</th><th>Regular Expression Equivalence</th><th>Match Range</th><th>Example Match</th></tr></thead><tbody><tr><td><code>*</code></td><td><code>/[^&amp;]*/</code></td><td>Single parameter value (excluding <code>&amp;</code>)</td><td><code>^...?q=*123</code> -&gt; <code>...?q=abc123</code></td></tr><tr><td><code>**</code></td><td><code>/.*/</code></td><td>Any character (including <code>&amp;</code>)</td><td><code>^...?q=**123</code> -&gt; <code>...?q=abc&amp;test=123</code></td></tr></tbody></table><h2 id="regular-expression-matching" tabindex="-1">Regular Expression Matching <a class="header-anchor" href="#regular-expression-matching" aria-label="Permalink to &quot;Regular Expression Matching&quot;">‚Äã</a></h2><p>In addition to simple matching rules, Whistle provides full regular expression support, with syntax fully compatible with JavaScript regular expressions:</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/pattern/[flags]</span></span></code></pre></div><ul><li>pattern: Regular expression body</li><li>flags: Matching pattern modifiers (optional) Supported: <ul><li><code>i</code> Ignore case <code>/abc/i</code> Matches &quot;AbC&quot;</li><li><code>u</code> Enable Unicode support <code>/\\p{Emoji}/u</code> Matches &quot;üòÄ&quot;</li></ul></li></ul><p>Example:</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/\\.test\\./ # Matches &quot;.test.&quot;</span></span>
<span class="line"><span>/key=value/i # Matches &quot;key=value&quot; ignoring case</span></span>
<span class="line"><span>/\\/statics\\//ui # Matches &quot;/statics/&quot; using the Unicode pattern</span></span></code></pre></div><h2 id="submatch-passing-values" tabindex="-1">Submatch Passing Values <a class="header-anchor" href="#submatch-passing-values" aria-label="Permalink to &quot;Submatch Passing Values&quot;">‚Äã</a></h2><p>In Whistle rule configuration, you can use $0, $1, through $9 to reference submatches of wildcard or regular expression matches and pass them into the action value:</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pattern protocol://$0_$1_$2_..._$1</span></span></code></pre></div><ul><li><strong>$0</strong>: Complete match result</li><li><strong>$1 - $9</strong>: Content of the corresponding capture group</li></ul><h4 id="wildcard-match-passing-values" tabindex="-1">Wildcard Match Passing Values <a class="header-anchor" href="#wildcard-match-passing-values" aria-label="Permalink to &quot;Wildcard Match Passing Values&quot;">‚Äã</a></h4><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>^http://*.example.com/v0/users/** file:///User/xxx/$1/$2</span></span></code></pre></div><ul><li><strong>Match</strong>: <code>http://www.example.com/v2/users/alice/test.html?q=1</code></li><li><strong>Value</strong>: <ul><li><code>$1</code> = <code>www</code></li><li><code>$2</code> = <code>users/alice</code></li></ul></li><li>Result: Replaces the contents of the local file <code>/User/xxx/www/alice/test.html</code></li></ul><h4 id="regular-expression-matching-and-value-passing" tabindex="-1">Regular Expression Matching and Value Passing <a class="header-anchor" href="#regular-expression-matching-and-value-passing" aria-label="Permalink to &quot;Regular Expression Matching and Value Passing&quot;">‚Äã</a></h4><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>/regexp\\/(user|admin)\\/(\\d+)/ reqHeaders://X-Type=$1&amp;X-ID=$2</span></span></code></pre></div><ul><li><strong>Match</strong>: <code>.../regexp/admin/123</code></li><li><strong>Value</strong>: <ul><li><code>$1</code> = <code>admin</code></li><li><code>$2</code> = <code>123</code></li></ul></li><li><strong>Result</strong>: Adds the request headers <code>X-Type: admin</code> and <code>X-ID: 123</code></li></ul>`,38)]))}const m=a(l,[["render",d]]);export{u as __pageData,m as default};
