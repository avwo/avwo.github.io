import{_ as t,c as d,o as r,ae as c}from"./chunks/framework.Dgg8-8ov.js";const u=JSON.parse('{"title":"Filters","description":"","frontmatter":{},"headers":[],"relativePath":"en/docs/rules/filters.md","filePath":"en/docs/rules/filters.md"}'),o={name:"en/docs/rules/filters.md"};function a(l,e,n,i,s,p){return r(),d("div",null,e[0]||(e[0]=[c('<h1 id="filters" tabindex="-1">Filters <a class="header-anchor" href="#filters" aria-label="Permalink to &quot;Filters&quot;">​</a></h1><p>When matching based on request or response attributes (not just the URL), you can use filters to achieve more granular rule control. The syntax is:</p><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pattern operator includeFilter://pattern1 ... excludeFilter://patternx ...</span></span></code></pre></div><blockquote><p>Multiple filters are matched &quot;or&quot;; as long as one of the filter conditions matches, the match is true.</p></blockquote><h2 id="filter-types" tabindex="-1">Filter Types <a class="header-anchor" href="#filter-types" aria-label="Permalink to &quot;Filter Types&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Filter Type</th><th>Syntax</th><th>Purpose</th></tr></thead><tbody><tr><td><strong>Include Filter</strong></td><td><code>includeFilter://pattern</code></td><td>Match only requests that match the specified conditions</td></tr><tr><td><strong>Exclude Filter</strong></td><td><code>excludeFilter://pattern</code></td><td>Exclude requests that match the specified conditions</td></tr></tbody></table><h2 id="pattern-types" tabindex="-1">Pattern Types <a class="header-anchor" href="#pattern-types" aria-label="Permalink to &quot;Pattern Types&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Syntax</th><th>Purpose</th><th>Example</th></tr></thead><tbody><tr><td><code>b:pattern</code></td><td>Match request body content</td><td><code>includeFilter://b:keyword</code> <code>excludeFilter://b:/regexp/[i]</code></td></tr><tr><td><code>m:pattern</code></td><td>Match HTTP method</td><td><code>includeFilter://m:keyword</code> <code>excludeFilter://m:/regexp/[i]</code></td></tr><tr><td><code>i:pattern</code></td><td>Match client or server IP</td><td><code>includeFilter://i:keyword</code> <code>excludeFilter://i:/regexp/[i]</code></td></tr><tr><td><code>chance:probability</code></td><td><code>Math.random() &lt; probability</code></td><td><code>includeFilter://chance:0.5</code> <code>excludeFilter://chance:0.3</code></td></tr><tr><td><code>clientIp:pattern</code></td><td>Match only client IP</td><td><code>includeFilter://clientIp:/regexp/[i]</code> <code>excludeFilter://clientIp:keyword</code></td></tr><tr><td><code>serverIp:pattern</code></td><td>Match only server IP</td><td><code>includeFilter://serverIp:/regexp/[i]</code> <code>excludeFilter://serverIp:keyword</code></td></tr><tr><td><code>s:pattern</code></td><td>Match response status code</td><td><code>includeFilter://s:/^20/</code> <code>excludeFilter://s:30</code></td></tr><tr><td><code>h:name=pattern</code></td><td>Match request/response headers</td><td><code>includeFilter://h:content-type=json</code> <code>excludeFilter://h:content-type=/regexp/i</code></td></tr><tr><td><code>reqH:name=pattern</code></td><td>Match request headers only</td><td><code>includeFilter://reqH:content-type=json</code> <code>excludeFilter://reqH:content-type=/regexp/i</code></td></tr><tr><td><code>resH:name=pattern</code></td><td>Match response headers only</td><td><code>includeFilter://resH:content-type=json</code> <code>excludeFilter://resH:content-type=/regexp/i</code></td></tr><tr><td>Other <code>xxxxxx</code></td><td>Match request URLs (same as <a href="./pattern.html">pattern</a>)</td><td><code>includeFilter://*/cgi-*</code> <code>excludeFilter://www.test.com</code> <code>includeFilter://https://www.test.com/path</code></td></tr></tbody></table>',8)]))}const x=t(o,[["render",a]]);export{u as __pageData,x as default};
