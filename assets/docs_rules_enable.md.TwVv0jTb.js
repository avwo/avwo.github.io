import{_ as a,c as s,o as n,ag as o}from"./chunks/framework.Bw-5EFTY.js";const x=JSON.parse('{"title":"enable","description":"","frontmatter":{},"headers":[],"relativePath":"docs/rules/enable.md","filePath":"docs/rules/enable.md"}'),c={name:"docs/rules/enable.md"};function l(t,e,d,p,i,r){return n(),s("div",null,e[0]||(e[0]=[o(`<h1 id="enable" tabindex="-1">enable <a class="header-anchor" href="#enable" aria-label="Permalink to &quot;enable&quot;">​</a></h1><p>通过规则启用 HTTPS、隐藏请求、终止请求等功能。</p><h2 id="规则语法" tabindex="-1">规则语法 <a class="header-anchor" href="#规则语法" aria-label="Permalink to &quot;规则语法&quot;">​</a></h2><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pattern enable://action1|action2|... [filters...]</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 等效于：</span></span>
<span class="line"><span>pattern enable://action1 enable://action2 ... [filters...]</span></span></code></pre></div><table tabindex="0"><thead><tr><th>参数</th><th>描述</th><th>详细文档</th></tr></thead><tbody><tr><td>pattern</td><td>匹配请求 URL 的表达式</td><td><a href="./pattern.html">匹配模式文档</a></td></tr><tr><td>action</td><td>具体动作，详见下面的说明</td><td></td></tr><tr><td>filters</td><td>可选过滤器，支持匹配：<br>• 请求URL/方法/头部/内容<br>• 响应状态码/头部</td><td><a href="./filters.html">过滤器文档</a></td></tr></tbody></table><ul><li><code>abort</code>：请求或响应阶段中断请求（根据匹配阶段）</li><li><code>abortReq</code>：请求阶段中断请求</li><li><code>abortRes</code>：响应阶段中断请求</li><li><code>authCapture</code>：强制在转成 HTTPS 之前执行 <a href="./../extensions/dev.html#auth">auth hook</a>（默认是转成 HTTPS 请求后再执行插件的 auth hook）</li><li><code>auto2http</code>：开启 HTTPS 请求报 TLS 错误自动转成 HTTP 请求，默认情况下如果 serverIP 是本地 IP 会自动启用</li><li><code>bigData</code>：扩大抓包数据显示限制(2M→16M)</li><li><code>br</code>：启用 BR 压缩响应内容</li><li><code>gzip</code>：启用 GZIP 压缩响应内容</li><li><code>deflate</code>：启用 Deflate 压缩响应内容</li><li><code>capture</code> 或 <code>https</code>：Enable HTTPS（同 <a href="./../gui/https.html">HTTPS菜单功能</a>）</li><li><code>captureIp</code> ：域名为 IP 的请求，默认不解密 HTTPS 请求，可以通过 <code>enable://captureIp</code> 启用解析 HTTPS 请求</li><li><code>captureStream</code>：将抓取到的请求与响应内容以数据流的形式，实时输出到抓包界面并动态追加显示</li><li><code>clientCert</code>：启用客户端与服务器之间的双向认证 (mTLS)</li><li><code>clientId</code>：请求头带上 <code>x-whistle-client-id: Whistle本地生成的唯一ID</code></li><li><code>clientIp</code>：为匹配的非本地请求设置 <code>x-forwarded-for</code> 请求头，将客户端的真实IP地址透传给上游服务</li><li><code>customParser</code>：自定义抓包界面显示内容，用法参考插件：<a href="https://github.com/whistle-plugins/whistle.custom-parser" target="_blank" rel="noreferrer">https://github.com/whistle-plugins/whistle.custom-parser</a></li><li><code>flushHeaders</code>：<code>response.writeHead(...)</code> 后调用 <a href="https://nodejs.org/docs/latest/api/http.html#responseflushheaders" target="_blank" rel="noreferrer">response.flushHeaders</a>（默认执行）</li><li><code>forHttp</code>：让 <code>capture</code> 功能只对 HTTP 请求生效</li><li><code>forHttps</code>：让 <code>capture</code> 功能只对 HTTPS 请求生效</li><li><code>forceReqWrite</code>：使用 <a href="./reqWrite.html">reqWrite</a>、<a href="./reqWriteRaw.html">reqWriteRaw</a> 将请求数据写入本地文件时，如果对应的文件已存在，默认跳过写入操作以保护现有文件，可以通过 <code>enable://forceReqWrite</code> 强制覆盖</li><li><code>forceResWrite</code>： 使用 <a href="./resWrite.html">resWrite</a>、<a href="./reqWriteRaw.html">reqWriteRaw</a> 将响应数据写入本地文件时，如果对应的文件已存在，默认跳过写入操作以保护现有文件，可以通过 <code>enable://forceResWrite</code> 强制覆盖</li><li><code>h2</code>：Whistle 代理 -&gt; 服务器启用 HTTP2</li><li><code>http2</code>：浏览器 -&gt; Whistle 代理 -&gt; 服务器全部启用 HTTP2</li><li><code>httpH2</code>：Whistle 代理 -&gt; 服务器的 HTTP 请求启用 HTTP2</li><li><code>hide</code>：在界面上隐藏抓包数据（不包括 <code>captureError</code> 和 Composer 发出的请求）</li><li><code>hideComposer</code>：隐藏 Composer 发出的请求</li><li><code>hideCaptureError</code>：隐藏 <code>captureError</code> 请求</li><li><code>showHost</code>：将服务器 IP 设置到响应头 <code>x-host-ip</code></li><li><code>ignoreSend</code>：WebSocket 和 TUNNEL 请求时忽略发送数据帧（TUNNEL 请求要启用 <code>inspect</code>）</li><li><code>ignoreReceive</code>：WebSocket 和 TUNNEL 请求时忽略接收数据帧（TUNNEL 请求要启用 <code>inspect</code>）</li><li><code>pauseSend</code>：WebSocket 和 TUNNEL 请求时暂停发送数据帧（TUNNEL 请求要启用 <code>inspect</code>）</li><li><code>pauseReceive</code>：WebSocket 和 TUNNEL 请求时暂停接收数据帧（TUNNEL 请求要启用 <code>inspect</code>）</li><li><code>inspect</code>：使的在 Inspectors / Frames 看到 TUNNEL 请求的内容</li><li><code>interceptConsole</code>：截获 <code>console.xxx</code> 的请求并显示在 Whistle 管理界面的 Log 面板（默认开启）</li><li><code>internalProxy</code>：利用 <code>proxy</code>、<code>socks</code> 等代理协议将请求转发至其他代理服务器（如另一 Whistle 实例）。启用此功能后，已在第一层代理解密的 HTTPS 请求将以明文形式在代理链中传输，从而上游代理可以直接获取明文数据</li><li><code>proxyFirst</code>：优先使用 <a href="./proxy.html">proxy</a> 规则（默认情况下，同时匹配 <code>host</code> 和 <code>proxy</code>，只有 <code>host</code> 生效）</li><li><code>proxyHost</code>：<a href="./proxy.html">proxy</a> 和 <a href="./host.html">host</a> 同时生效</li><li><code>proxyTunnel</code>：跟 <code>proxyHost</code> 一同使用，让上游代理再次通过隧道代理到上上游的 HTTP 代理，详见下面的示例</li><li><code>keepCSP</code>：通过 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code> 注入内容时会自动删除响应头大 <code>csp</code> 字段，如果想保留这些字段可以用 <code>enable://keepCSP</code></li><li><code>keepAllCSP</code>：通过 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code>/<code>weinre</code>/<code>log</code> 注入内容时会自动删除响应头的 <code>csp</code> 字段，如果想保留这些字段可以用 <code>enable://keepAllCSP</code></li><li><code>keepCache</code>：通过 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code> 注入内容时会自动删除响应头的缓存字段，如果想保留原有的缓存头可以用 <code>enable://keepCache</code></li><li><code>keepAllCache</code>：通过 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code>/<code>weinre</code>/<code>log</code> 注入内容时会自动删除响应头的缓存字段，如果想保留原有的缓存头可以用 <code>enable://keepAllCache</code></li><li><code>keepClientId</code>：保留请求原有的 <code>x-whistle-client-id</code> 请求头（默认会删除请求带过来的 <code>x-whistle-client-id</code>）</li><li><code>safeHtml</code>：是一种安全防护机制，当使用 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code> 向 HTML 页面注入内容时，会先检查响应内容的第一个非空白字符是否为 <code>{</code> 和 <code>[</code>（JSON 对象开头字符），如果不是才会执行注入操作。这可以有效防止对非标准 HTML 响应（如 JSON 接口）的误注入</li><li><code>strictHtml</code>：是一种安全防护机制，当使用 <code>htmlXxx</code>/<code>jsXxx</code>/<code>cssXxx</code> 向 HTML 页面注入内容时，会先检查响应内容的第一个非空白字符是否为 <code>&lt;</code>，如果不是才会执行注入操作。这可以有效防止对非标准 HTML 响应（如 JSON 接口）的误注入</li><li><code>multiClient</code>：Whistle 作为公共代理且启用 <code>enable://clientId</code> 时会为所有请求添加一个固定的 <code>x-whistle-client-id</code> 请求头，这导致上游服务无法区分不同客户端。启用 <code>enable://multiClient</code> 后，将为每个客户端连接生成并维持一个唯一且不变的标识符，确保上游服务能准确识别请求来源</li><li><code>requestWithMatchedRules</code>：在请求头带上当前匹配的规则</li><li><code>responseWithMatchedRules</code>：在响应头带上当前匹配的规则</li><li><code>tunnelHeadersFirst</code>：用于控制请求头合并的优先级。插件可通过 <a href="./../extensions/dev.html">tunnelKey</a> 将隧道（TUNNEL）请求头传递至后续阶段。默认的合并规则是：若隧道头与解析后的普通请求头存在同名键，则保留普通请求头的值。启用 <code>enable://tunnelHeadersFirst</code> 可改变这一行为，确保隧道请求头优先，从而强制覆盖任何冲突的普通头</li><li><code>useLocalHost</code>：修改 <code>log</code> 和 <code>weinre</code> 请求 <code>URL</code> 的域名，使用内置域名</li><li><code>useSafePort</code>：修改 <code>log</code> 和 <code>weinre</code> 请求 <code>URL</code> 的端口，使用内置端口</li><li><code>userLogin</code>：设置 <a href="./statusCode.html">statusCode://401</a> 是否显示登录框（默认显示）</li><li><code>weakRule</code>：默认情况下，当配置了 <a href="./file.html">file</a> 等协议时，<a href="./proxy.html">proxy</a> 规则会自动失效。通过设置 <code>weakRule</code> 属性，可以提升 <a href="./proxy.html">proxy</a> 规则的优先级，使其在上述场景中仍然生效</li><li><code>socket</code>：在启用 HTTPS 解析（<code>Enable HTTPS</code> 或 <code>enable://https</code>）后，发往 <code>80/443</code> 端口的 TUNNEL 请求会被强制尝试解析为 HTTP/HTTPS 流量。默认情况下，若解析失败，该连接将被销毁；而其他端口的请求解析失败则会继续以 TUNNEL 方式传输。通过设置 <code>enable://socket</code>，可让发往 <code>80/443</code> 端口的请求在解析失败时同样降级为 TUNNEL 连接，避免连接被销毁</li><li><code>websocket</code>：用于处理非标准 WebSocket 连接。某些请求虽使用 WebSocket 协议传输，但其 Upgrade 请求头并非标准值（如 <code>Upgrade: websocket</code>）。默认情况下，Whistle 会将其视为普通 TCP 连接而不解析数据。启用 <code>enable://websocket</code> 可强制 Whistle 识别此类连接为 WebSocket 协议并进行数据解析</li></ul><h2 id="配置示例" tabindex="-1">配置示例 <a class="header-anchor" href="#配置示例" aria-label="Permalink to &quot;配置示例&quot;">​</a></h2><div class="language-txt vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">txt</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># Enable HTTPS</span></span>
<span class="line"><span>www.example.com enale://https</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 延迟 3000毫秒终止请求</span></span>
<span class="line"><span>www.example.com/path reqDelay://3000 enable://abortReq</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 延迟 5000毫米终止响应</span></span>
<span class="line"><span>www.example.com/path resDelay://5000 enable://abortRes</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 本地替换的内容开启 GZIP</span></span>
<span class="line"><span>www.example.com/path file:///User/xxx/test enable://gzip</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 给上游代理设置 hosts (10.10.10.20:8888)</span></span>
<span class="line"><span>www.example.com/path proxy://10.1.1.1:8080 10.10.10.20:8888 enable://proxyHost</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 通过上游 HTTP 代理 (10.1.1.1:8080) 将请求通过隧道代理到指定的 HTTP 代理(10.10.10.20:8080)</span></span>
<span class="line"><span>www.example.com proxy://10.1.1.1:8080 10.10.10.20:8080 enable://proxyHost|proxyTunnel</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 启用浏览器 -&gt; Whistle 代理 -&gt; 服务器整个链路的 HTTP2 功能</span></span>
<span class="line"><span>www.example.com enable://http2</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 启用 Whistle 代理 -&gt; 服务器的 HTTP2 功能</span></span>
<span class="line"><span>www.example.com enable://h2</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 强制 Whistle 代理 -&gt; 服务器的 HTTP 请求使用 HTTP2 传输</span></span>
<span class="line"><span>www.example.com enable://httpH2</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 安全注入模式：当使用 htmlXxx/jsXxx/cssXxx 注入指令时，检测响应首字符不是 \`{\` 才注入</span></span>
<span class="line"><span>www.example.com/path enable://safeHtml</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 严格HTML注入模式：当使用 htmlXxx/jsXxx/cssXxx 注入指令时，检测响应首字符不是 \`&lt;\` 才注入</span></span>
<span class="line"><span>www.example.com/path enable://strictHtml</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 自动添加 x-forwarded-for 请求头传递客户端真实 IP</span></span>
<span class="line"><span>www.example.com enable://clientIp</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 扩大抓包数据显示限制(2M→16M)</span></span>
<span class="line"><span>www.example.com/path enable://bigData</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 修改 log/weinre 请求 \`URL\` 的域名或端口</span></span>
<span class="line"><span>www.example.com/path enable://useLocalHost|useSafePort</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 强制 reqWrite/reqWriteRaw/resWrite/resWriteRaw 覆盖已有的文件</span></span>
<span class="line"><span>www.example.com/path enable://forceReqWrite|forceResWrite</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 强制 HTTPS 请求被解析前也走 \`auth hook\`（默认是转成 HTTPS 请求后再执行插件的 auth hook）</span></span>
<span class="line"><span>www.example.com enable://authCapture</span></span></code></pre></div><p>关联操作：<a href="./disable.html">disable</a></p>`,9)]))}const m=a(c,[["render",l]]);export{x as __pageData,m as default};
